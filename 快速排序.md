# 快速排序

## 快速排序的基本原理

首先我们要对一组数据进行排序：

1. 在数组中选一个基准数（通常为数组第一个，黄圈圈标记了）；
2. 将数组中小于基准数的数据移到基准数左边，大于基准数的移到右边，怎么移动，后面说；
3. 对于基准数左、右两边的数组，不断重复以上两个过程，直到每个子集只有一个元素，即为全部有序。

主要操作：

快速排序需要两个哨兵，i （&）和 j（*）,分别指向数组的头和尾。

数组： &6 4 3 5 7 1 4 9 *0



我们通常选择第一个元素作为基准数，去移动数组元素，使其达到这个基准数的左边都是小于它的，右边都是大于它的。开始移动 i 和 j , i 和 j 是交互移动的，这里我们需要先移动 j，这是为甚呢，原因是先移动 j,等到这一行移动结束，i 的下一个就是 j 的时候，我们先移动 j ,可以避免将数据移动错误，后面会有体会。
当移动 j 时，就开始比较 j 是否比基准数大，如果大于或者等于就 j–,否则再看 i,如果 i 小于等于6，则i++ 再与基准数进行比较,否则 i 就要与 j指向的值互换

第一步：看j的值比6小，然后看i，i的值是6,所以i++,后面 i继续++，4，3，5都比6小，所以 i 就移动到了7下面。

- 6 4 3 5 &7 1 4 9 *0

到这里，j 所指向的值要与 i 所指向的值互换。

- 6 4 3 5 &0 1 4 9 *7

互换完成，后面在比较 j 所指向的位置是否比基准数大，如果大就 j–;
这里 7 ， 9 ,都比6大，所以j–,进行两次，j 就到达了4的下面。

- 6 4 3 5 &0 1 *4 9 7

4比6小，所以要再看 i，i 指向0，所以 i需要 i++,到 1，1也小于6, 所以 i 还需要++，到这里 i 就和 j指向同一个数4

- 6 4 3 5 0 1 &*4 9 7

然后 i = j 了，不能够满足条件，所以就要进行互换，将 i 指向的数，与基准数互换，这一轮比较就结束了

- 4 4 3 5 0 1 6 9 7

到这里，基准数6的左边都比6小，右边都比6大。后面还是按照这个来分别再基准数6的左右开始比较。

核心代码

```c
void quick_sort(int num[], int low, int high )
{
    int i,j,temp;
    int tmp;

    i = low;
    j = high;
    tmp = num[low];   //任命为中间分界线，左边比他小，右边比他大,通常第一个元素是基准数

    if(i > j)  //如果下标i大于下标j，函数结束运行
    {
        return;
    }

    while(i != j)
    {
        while(num[j] >= tmp && j > i)   
        {
            j--;
        }

        while(num[i] <= tmp && j > i)
        {
            i++;
        }

        if(j > i)
        {
            temp = num[j];
            num[j] = num[i];
            num[i] = temp;
        }
    }

    num[low] = num[i];
    num[i] = tmp;

    quick_sort(num,low,i-1);
    quick_sort(num,i+1,high);
}

```



## 双路快速排序

我们在用高度有序的数组进行测试的时候，发现快速排序的效率变得异常的低下，比归并排序的效率低得多了，近似退回了O（n^2）的复杂度，这是为什么呢？首先让我们来分析一下归并排序的算法思想，归并排序之所以能够达到O(logn)的复杂度，多亏了递归，递归使得把数组不断的二分分小分到不能分为止，然后再从小的数组开始解决，一直返回回去直到把最后一个最大的数组完成，任务就完成了，因此归并的复杂度为O（nlogn）;

而相对于快速排序来说，归并排序的分类依据是从中间二分之一开始不停的分下去，这样保证了分的每段数组都是均匀的，也就是说形成的递归二叉树相对来说比较的稳定，而对于快速排序的分类方法来说，快速排序是以数组中的第一位元素为参考为来把数组分类的，因此在特殊情况（数组高度有序）的情况下，快速排序的分类可能导致数组分的并不均匀，效率将会大大降低，达不到O（nlogn）的复杂度，分出来的数组可能一边多一边少

因此，我们需要对快速排序进行优化，使其在碰到高度有序的数组时也能够轻松应对，

首先，我们分析快速排序之所以会退化的原因是数组的分配方法导致数组分类不均，因此我们需要修改快速排序的数组分类方法，尽量减少这种情况的产生，因为我们每次都以数组的第一位作为标准，这就产生了局限，因此我们只要更改数组的参考位置，不要每次都设置为数组第一位就行了，我们可以用数组中的任意一个数来作为参考值，增加其随机性来应对高度有序的数组，我们可以用rand()方法生成一个随机数作为参考数位置的下标，在把arr【l】与其进行调换，避免数组分配不均的情况，我们只需要修改_partion函数的定义即可：

然而，即使解决了这个问题使得快速排序法面对高度有序的数组的问题时，当面对存在大量重复数字的数组时，快速排序法也会显得力不从心，分配的数组将会有一边倒的趋势：

因此，我们要换一个思路来写partion函数，之前我们都是把大于小于数统统放到一边，这一次我们采用双路快速排序法来提高效率，使其不用靠i一个变量遍历完所有的数据，我们可以增加一个变量j从数组的尾端同时遍历数组

增加一个变量j，当i从左往右遍历数组时，碰到不符合小于V的数时停止，然后j从数组的右边开始遍历，碰到属于大于V的数时停止，此时我们只需要交换一下i.j指向的数据就可以了，然后重复i扫描，j扫描，交换两个数的操作，即使i和j所指向的数据相等时（都等于V）也会进行交换一次，防止了大量等于V的数据全部推到一边去了。

核心代码

```c
template<typename T>
int __partion(T arr[],int l,int r)//分类子操作，最后返回V处于的位置下标
{
    srand(time(NULL));//随机种子
    swap(arr[l],arr[rand()%(r-l+1)+l]);//随机取参考值的大小
    T v=arr[l];//记录参考值的大小用来作为分类的依据
    int i=l+1,j=r;
    while(true) 
    {
        while(i<=r&&arr[i]<v) i++;//之所以不加=V条件的作用是让=V的数据也进行交换
        while(j>=l+1&&arr[j]>v)j--;
        if(i>j) break;//i.j全部寻找完毕
        swap(arr[i],arr[j]);//交换值
        i++;
        j--;
 
    }
    swap(arr[l],arr[j]);//把参考值提到中间来
    return j;
}

```



### 三路快速排序

**初始化**：左边界为l,右边界是r，‘<’集合内的最大值（最右侧）记为lt初始记为l，‘=’记为等于v值的数，’>'集合内的最小值（最左边）的前一位，记为gt（不属于‘>’集合内的元素）。记i为当前位置下标，初始化为lt+1。

**过程**：从当前位置i开始，逐个与v比较，如果小于v，则与lt+1下标的值交换，并且i++（继续比较），如果大于，便与下标为gt-1的值交换（注意i值不变，因为此时不能判断原gt-1的值与v的大小关系，需要再进行比较），比较至i值等于gt值结束。递归左右两侧集合，在进行排序。最后可完成n个整数的排序排序

核心代码

```c++
void Q3Details(int arr[],int l,int r)
{
	
	if(l>=r)
	return ;
	
	int v=arr[l];
	int lt=l;
	int gt=r+1;
	int i=l+1;
	while(i<gt)
	{
		if(arr[i]<v)		//第i个整数比首个整数小，交换左边界+1与第i个数，i++ 
		{swap(arr[i],arr[lt+1]);
		lt++;
		i++;}
		
		else if(arr[i]>v)			// 第i个整数比首个整数大，交换右边界-1与第i个数
		{
			swap(arr[i],arr[gt-1]);
			gt--;
		}
		
		else	// 第i个整数与首个整数相等，则归入相等集合，当前指针右移 
		{
		i++;
}
	}
		//一轮排序完成后，左边界左边全小于首个整数， 右边界右侧全部大交换首数字与左边界最右侧数字，
	
	swap(arr[l],arr[lt]);	//交换首数字与左边界最右侧数字， 
	 Q3Details(arr,l,lt-1);	//递归左侧与右侧集合 
	 Q3Details(arr,gt,r);
	
	
}

```

